#!/usr/bin/env -S Rscript --no-save --no-restore --no-site-file

#===============================================================================
# Usage: score n1 n2 [n3] ... [conf]
#
# Calculate a Bayesian Approximation of an ordinal score. All n[x]
# values must be integers, corresponding to the number of ratings of [x]
# value. Can optionally provide [conf] to calculate confidence interval
# for a specific level. Default confidence interval is .95.
#===============================================================================

#===============================================================================
# Scoring functions
#===============================================================================

# Valid scoring functions
scorers <- c(
  "wilson",
  "ordinal"
)

#'------------------------------------------------------------------------------
#' wilson_score
#'
#' Calculate lower bound binomial confidence interval
#'
#' @param pos integer-valued scalar count of successes
#' @param n integer-valued scalar count of trials
#' @param conf decimal-valued scalar of desired confidence level
#' @return scalar, calculated Wilson score
#' @examples
#' wilson_score(5, 6, .99)
#'------------------------------------------------------------------------------
wilson_score <- function(pos, n, conf = .95) {
  if (n < pos) {
    return(cat("'n' must be equal to or less than pos"))
  }

  z <- qnorm(1 - (1 - conf) / 2)
  phat <- 1.0 * pos / n

  score <- (
    (phat
     + (z^2 / (2 * n))
     - (z * sqrt((phat * (1-phat) + z^2 / (4 * n)) / n)))
    /
    (1 + (z^2 / n))
  )

  return(score)
}

#'------------------------------------------------------------------------------
#' @ ordinal_score
#'
#' Calculate lower bound Bayesian confidence interval
#'
#' @param n numeric vector of integer values, corresponding to the number of
#'   ratings per rating level (e.g. 5 one-star, 4 two-star, 1 three-star)
#' @param conf decimal-valued scalar of desired confidence level
#' @return scalar, calculated lower bound Bayesian confidence interval
#' @examples
#' ordinal_score(c(0, 4, 8, 2, 0), .99)
#'------------------------------------------------------------------------------
ordinal_score <- function(n, conf = .95) {
  K <- length(n)
  N <- sum(n)
  z <- qnorm(1 - (1 - conf) / 2)

  sum1 <- sum(sapply(seq(n), function(k) (k * (n[k] + 1) / (N + K))))
  sum2 <- sum(sapply(seq(n), function(k) (k^2 * (n[k] + 1) / (N + K))))

  score <- sum1 - z * sqrt((sum2 - sum1^2) / (N + K + 1))

  return(score)
}

#===============================================================================
# Main script
#===============================================================================
main <- function() {

  # Get args
  args <- commandArgs(trailingOnly = T)

  # No arguments passed
  if(length(args) < 1) {
    args <- "--help"
  }

  # Define --help option
  if(!is.na(match("--help", args))) {
    return(
      cat(
        "Usage: ordinal_score n1 n2 [n3] ... [conf]",
        "\n\n",
        "Calculate a Bayesian Approximation of an ordinal score. All n[x] ",
        "values must be integers, corresponding to the number of ratings of ",
        "[x] value. Can optionally provide [conf] to calculate confidence ",
        "interval for a specific level. Default confidence interval is .95.",
        fill = 80
      )
    )
  }

  # Ensure valid first argument
  err1 <- expression(
    cat(
      "First argument must be one of ",
      "",
      scorers,
      sep = "\n",
      fill = 80
    )
  )

  scorer <- args[1]
  if (scorer != "wilson" & scorer != "ordinal") {
    return(eval(err1))
  }

  # Parse confidence level option, if provided
  conf_index <- match("--conf", args)
  if (!is.na(conf_index)) {
    conf <- tryCatch(
      as.numeric(args[conf_index + 1]),
      error = return(cat("Argument for option --conf must be numeric, decimal valued"))
    )
    args <- args[-(conf_index + 1)]
    args <- args[-conf_index]
  } else {
    conf <- .95
  }

  # Catch non-numeric arguments
  args <- tryCatch(
    as.numeric(args[-1]),
    error = function() return(cat("All arguments must be numeric."))
  )
  n_args <- length(args)

  # Catch < 2 arguments
  if (n_args < 2) {
    return(cat("Must provide at least two numeric arguments."))
  }

  # Calculate Wilson score
  if (scorer == "wilson") {

    # Catch > 3 arguments
    if (n_args > 3) {
      return("Maximum of 3 arguments accepted for Wilson scoring")
    }

    # Final parameters
    pos <- ifelse(
      args[1] %% 1 != 0,
      round(args[1] * args[2]),  # If proportion, convert to integer count
      args[1]
    )
    n <- args[2]

    # Calculate score
    result <- wilson_score(pos, n, conf)

  }
  else if (scorer == "ordinal") {

    # Catch non-integer arguments for n arguments < 3
    ints <- sapply(args, function(x) x %% 1 == 0)
    if (!any(ints)) {
      return(
        cat(
          "All arguments must be integers.",
          fill = 80
        )
      )
    }
    n <- args

    # Calculate score
    result <- ordinal_score(n, conf)
  }

  cat(result, fill = 80)
}

main()
